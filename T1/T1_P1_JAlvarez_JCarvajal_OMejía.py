# -*- coding: utf-8 -*-
"""T1_P1_JÁlvarez-JCarvajal-OMejía.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10ptdf41OzUchjUB6j274T0NEx3EMjvTg

# <center> Trabajo 1 
## <center> **$Punto \ 1. \ Diferenciación \ e \ integración \ numéricas$**
<br>  
<center> Juan Diego Alvarez Perdomo <br /> Juliana Carvajal Guerra <br /> Oriana Mejía Cardona
<br>  
<center><img src="https://raw.githubusercontent.com/jda-21/metPy/master/IMG/Escudo%20UDEA.png" width="200"">
<br>
<center> Programación y métodos numéricos <br /> Facultad de Ingeniería <br /> Departamento de Ingeniería Mecánica <br /> Universidad de Antioquia <br /> Medellín
 <center> Enero de 2021


---

# *$Enunciado$*
Durante un proyecto de análisis de emisiones, se midió el ciclo de conducción típico de vehículos ligeros en una ciudad, el cual se expresa como una curva de velocidad en función del tiempo (ver figura 1).
<br> 
<img src="https://raw.githubusercontent.com/jda-21/metPy/master/IMG/Figura%201.png" width = "500px">
<br>
Durante este ciclo se midieron también las emisiones de bióxido de carbon (flujo másico instantáneo), tal como se puede ver en la figura 2.
<br>
<img src="https://raw.githubusercontent.com/jda-21/metPy/master/IMG/Figura%202.png" width = "500px">
<br>
Esta información se midió con un sistema de adquisición de datos que recoge 10 datos por segundo. El archivo de datos correspondiente se denomina “Datos_ciclo.xlsx”.

# *$Contenido$*

En este cuaderno se utilizan métodos de diferenciación e integración para hallar las soluciones a cada uno de los puntos. 

1.   En este punto utilizamos integración para hallar la distancia total recorrida, utilizando dos reglas, la regla trapezoidal y las reglas de Simpson.

  Adicionalmente, sacamos el promedio de la velocidad.
2.   En este punto utilizamos diferenciación númeria para hallar la aceleración mínima y máxima en el ciclo.
3.   En este punto volvemos a utilizar la regla trapezoidal y las reglas de Simpson para hallar el factor de emisión de CO2, este lo hallamos primero utilizando para encontrar la masa total de CO2 y luego dividiendo esta entre la distancia recorrida hallada en el primer numeral. 

Para los tres numerales utilizamos dos pasos o frecuencias diferentes, $0.1s$ y $1s$.
"""

# Importación de librerías
import pandas as pd
import numpy as np
import matplotlib.pyplot as mplt
from IPython.display import HTML, display_html, display

# Lectura de datos
DF_datos_ciclo = pd.read_excel('https://github.com/jda-21/metPy/blob/master/T1/Datos_ciclo.xlsx?raw=true')
DF_datos_ciclo

"""# 1. Determinar la distancia total recorrida durante el ciclo, en $km$, así como la velocidad media del ciclo, en $km/h$.

"""

list_V_km_s = []     # Se crea una lista en la que se almacenarán los valores de la velocidad en [km/s].
for i in DF_datos_ciclo['V [km/h]']:
    list_V_km_s.append(i/3600)     # Se convierten los valores de la velocidad de [km/h] a [km/s].

"""## Regla trapezoidal"""

t1_dist_t = 0     # Se crea una variable para almacenar el valor de la distancia recorrida.
for i in range(len(DF_datos_ciclo['t [s]']) - 1):
  t1_dist_t = t1_dist_t + (DF_datos_ciclo['t [s]'][i+1] - DF_datos_ciclo['t [s]'][i]) * ((list_V_km_s[i] + list_V_km_s[i+1])) / 2     # Se aplica la regla trapezoidal con una frecuencia de 0.1 s.
print('La distancia total recorrida es: ', t1_dist_t, '[km]')     # Se muestra el resultado.

t2_dist_t = 0     # Se crea una variable para almacenar el valor de la distancia recorrida.
for i in range(0, len(DF_datos_ciclo['t [s]']) - 1, 10):
  t2_dist_t = t2_dist_t + (DF_datos_ciclo['t [s]'][i+10] - DF_datos_ciclo['t [s]'][i]) * ((list_V_km_s[i] + list_V_km_s[i+10])) / 2     # Se aplica la regla trapezoidal con una frecuencia de 1 s.
print('La distancia total recorrida es: ', t2_dist_t, '[km]')     # Se muestra el resultado.

"""## Reglas de Simpson

### Regla de Simpson 1/3
"""

s1_dist_t = 0     # Se crea una variable para almacenar el valor de la distancia recorrida.
for i in range (len(DF_datos_ciclo['t [s]']) - 2):
  s1_dist_t = s1_dist_t + (DF_datos_ciclo['t [s]'][i+1] - DF_datos_ciclo['t [s]'][i]) * ((list_V_km_s[i] + 
  4*(list_V_km_s[i+1]) + list_V_km_s[i+2]))/6     # Se aplica la regla de Simpson 1/3 con una frecuencia de 0.1 s.
print('La distancia total recorrida es: ', s1_dist_t, '[km]')     # Se muestra el resultado.

"""### Reglas de Simpson combinadas"""

dist_1_3 = 0     # Se crea una variable para almacenar el valor de la distancia recorrida.
for i in range (0,len(DF_datos_ciclo['t [s]']) - 31,10):
  dist_1_3 = dist_1_3 + (DF_datos_ciclo['t [s]'][i+10] - DF_datos_ciclo['t [s]'][i]) * ((list_V_km_s[i] +
  4*(list_V_km_s[i+10]) + list_V_km_s[i+20]))/6     # Se aplica la regla de Simpson 1/3 con una frecuencia de 1 s, en todos los segmentos, excepto los 3 últimos.

dist_3_8 = (DF_datos_ciclo['t [s]'][20630] - DF_datos_ciclo['t [s]'][20620]) * (((list_V_km_s[20620] + 
 3*(list_V_km_s[20630]) + 3*(list_V_km_s[20640]) + list_V_km_s[20650])) / (8))     # Se aplica la regla de Simpson 3/8 con una frecuencia de 1 s en los tres últimos segmentos.

s2_dist_t = dist_1_3 + dist_3_8     # Se suman las distancias obtenidas.
print('La distancia total recorrida es: ', s2_dist_t, '[km]')     # Se muestra el resultado.

d_dist = {'h':[0.1,1], 'Regla trapezoidal':[t1_dist_t, t2_dist_t], 'Reglas de Simpson':[s1_dist_t, s2_dist_t]}     # Se crea un diccionario con los resulados obtenidos.
DF_dist = pd.DataFrame(d_dist)    # Se crea un DataFrame a partir del diccionario creado.
DF_dist.set_index('h', inplace=True)    # Se utilizan las frecuencias como índices.
DF_dist    # Se muestra el DataFrame para comparar los resultados obtenidos por los diferentes métodos utilizados.
display(HTML('<h2>Distancia total recorrida</h2>'))
display_html(DF_dist)

"""## Velocidad media en $km/h$

"""

V_prom = sum(DF_datos_ciclo['V [km/h]']) / len(DF_datos_ciclo['V [km/h]'])     # Se calcula el promedio de los datos de velocidad dados.
print('La velocidad media del ciclo es: ', V_prom, '[km/h]')     # Se muestra el resultado.

"""# 2. Determinar las aceleraciones máxima y mínima durante el ciclo, en $m/s²$

<div align="justify">
Con el fin de estimar la aceleración en los instantes dados, se debe derivar la velocidad que se tiene, para lo cual se utilizan métodos de diferenciación numérica. Dado que la expresión de diferencias finitas centradas que entrega un error de truncamiento del orden de $h^{4}$ requiere de dos puntos previos y dos puntos posteriores, no puede ser usada ni en los dos primeros puntos ni en los dos últimos puntos. Por esto se utilizarán diferencias finitas hacia adelante O($h^{2}$) en los dos primeros y diferencias finitas hacia atrás O($h^{2}$) en los dos últimos.
</div>

Se tiene entonces, para los dos primeros puntos:

$$f'(x_{i})= \frac{-f(x_{i+2})+4f(x_{i+1})-3f(x_{i})}{2h}+O (h^{2})$$ 

$$a(t_{i})=\frac{dV(t_{i})}{dt}\cong \frac{-V(t_{i+2})+4V(t_{i+1})-3V(t_{i})}{2h}$$  

Para los dos últimos puntos:

$$f'(x_{i})= \frac{3f(x_{i})-4f(x_{i-1})+f(x_{i-2})}{2h}+O (h^{2})$$

$$a(t_{i})=\frac{dV(t_{i})}{dt}\cong \frac{3V(t_{i})-4V(t_{i-1})+V(t_{i-2})}{2h}$$

Para el resto de los puntos: 

$$f'(x_{i})= \frac{-f(x_{i+2})+8f(x_{i+1})-8f(x_{i-1})+f(x_{i-2})}{12h}+O (h^{4})$$

$$a(t_{i})=\frac{dV(t_{i})}{dt}\cong\frac{-V(t_{i+2})+8V(t_{i+1})-8V(t_{i-1})+V(t_{i-2})}{12h}$$
"""

V_m_s = (DF_datos_ciclo['V [km/h]'])*(1000/3600)     # Se convierten los valores de la velocidad de [km/h] a [m/s].

h = DF_datos_ciclo['t [s]'][1] - DF_datos_ciclo['t [s]'][0]     # Se establece el paso.

a1 = []     # Se crea una lista para almacenar los valores de la aceleración.
for i in range(2):
    a_t_i = (-V_m_s[i+2] + 4*(V_m_s[i+1]) - 3*(V_m_s[i])) / (2*h)     # Se calcula la aceleración para los dos primeros instantes.
    a1.append(a_t_i)
for i in range(2,len(V_m_s)-2):
    a_t_i = (-V_m_s[i+2] + 8*(V_m_s[i+1]) - 8*(V_m_s[i-1]) + (V_m_s[i-2])) / (12*h)     # Se calcula la aceleración para los instantes intermedios.
    a1.append(a_t_i)
for i in range(len(V_m_s)-2,len(V_m_s)):
    a_t_i = (3*V_m_s[i] - 4*(V_m_s[i-1]) + (V_m_s[i-2])) / (2*h)     # Se calcula la aceleración para los dos últimos instantes.
    a1.append(a_t_i)
print('La aceleración máxima durante el ciclo es: ', max(a1),'[m/s²]')     # Se muestra el valor máximo que tuvo la aceleración.
print('La aceleración mínima durante el ciclo es: ', min(a1),'[m/s²]')     # Se muestra el valor mínimo que tuvo la aceleración.

h = DF_datos_ciclo['t [s]'][10] - DF_datos_ciclo['t [s]'][0]     # Se establece el paso.

a2 = []     # Se crea una lista para almacenar los valores de la aceleración.
for i in range(0,11,10):
    a_t_i = (-V_m_s[i+20] + 4*(V_m_s[i+10]) - 3*(V_m_s[i])) / (2*h)     # Se calcula la aceleración para los dos primeros instantes.
    a1.append(a_t_i)
for i in range(20,len(V_m_s)-20, 10):
    a_t_i = (-V_m_s[i+20] + 8*(V_m_s[i+10]) - 8*(V_m_s[i-10]) + (V_m_s[i-20])) / (12*h)     # Se calcula la aceleración utilizando para los instantes intermedios.
    a2.append(a_t_i)
for i in range(len(V_m_s)-20,len(V_m_s),10):
    a_t_i = (3*V_m_s[i] - 4*(V_m_s[i-10]) + (V_m_s[i-20])) / (2*h)     # Se calcula la aceleración para los dos últimos instantes.
    a1.append(a_t_i)
print('La aceleración máxima durante el ciclo es: ', max(a2),'[m/s²]')     # Se muestra el valor máximo que tuvo la aceleración.
print('La aceleración mínima durante el ciclo es: ', min(a2),'[m/s²]')     # Se muestra el valor mínimo que tuvo la aceleración.

d_acel = {'Paso':[0.1,1], 'Aceleración máxima':[max(a1), max(a2)], 'Aceleración mínima':[min(a1), min(a2)]}     # Se crea un diccionario con los resulados obtenidos.
DF_acel = pd.DataFrame(d_acel)     # Se crea un DataFrame a partir del diccionario creado.
DF_acel.set_index('Paso', inplace=True)    # Se utilizan las frecuencias como índices.
DF_acel    # Se muestra el DataFrame para comparar los resultados obtenidos por los diferentes métodos utilizados.
display(HTML('<h2>Aceleración</h2>'))
display_html(DF_acel)

"""# 3. Determinar el factor de emisión de CO2, del vehículo, el cual se expresa como la masa total de CO2, dividida por la distancia total recorrida $[gCO2/km]$.

## Trapezoidal
"""

t1_m_CO2_t = 0     # Se crea una variable para almacenar el valor de la masa total de CO2.
for i in range(len(DF_datos_ciclo['t [s]']) - 1):
  t1_m_CO2_t = t1_m_CO2_t + (DF_datos_ciclo['t [s]'][i+1] - DF_datos_ciclo['t [s]'][i]) * ((DF_datos_ciclo['m_dot_CO2 [g/s]'][i] + 
  DF_datos_ciclo['m_dot_CO2 [g/s]'][i+1])) / 2     # Se aplica la regla trapezoidal con una frecuencia de 0.1 s.
t1_fact_emi_t = t1_m_CO2_t / t1_dist_t     # Se calcula el factor de emisión.
print('La masa total de CO2 es: ', t1_m_CO2_t, '[gCO2]')    # Se muestra la masa total de CO2.
print('El factor de emisión de CO2 del vehículo es: ', t1_fact_emi_t, '[gCO2/km]')     # Se muestra el factor de emisión.

t2_m_CO2_t = 0     # Se crea una variable para almacenar el valor de la masa total de CO2.
for i in range(0, len(DF_datos_ciclo['t [s]']) - 1, 10):
  t2_m_CO2_t = t2_m_CO2_t + (DF_datos_ciclo['t [s]'][i+10] - DF_datos_ciclo['t [s]'][i]) * ((DF_datos_ciclo['m_dot_CO2 [g/s]'][i] + 
  DF_datos_ciclo['m_dot_CO2 [g/s]'][i+10])) / 2     # Se aplica la regla trapezoidal con una frecuencia de 1 s.
t2_fact_emi_t = t2_m_CO2_t / t2_dist_t     # Se calcula el factor de emisión.
print('La masa total de CO2 es: ', t2_m_CO2_t, '[gCO2]')    # Se muestra la masa total de CO2.
print('El factor de emisión de CO2 del vehículo es: ', t2_fact_emi_t, '[gCO2/km]')     # Se muestra el factor de emisión.

"""## Reglas de Simpson

### Regla de Simpson 1/3
"""

s1_m_CO2_t = 0     # Se crea una variable para almacenar el valor de la masa total de CO2.
for i in range (len(DF_datos_ciclo['t [s]']) - 2):
  s1_m_CO2_t = s1_m_CO2_t + (DF_datos_ciclo['t [s]'][i+1] - DF_datos_ciclo['t [s]'][i]) * ((DF_datos_ciclo['m_dot_CO2 [g/s]'][i] + 
  4*(DF_datos_ciclo['m_dot_CO2 [g/s]'][i+1]) + DF_datos_ciclo['m_dot_CO2 [g/s]'][i+2]))/6     # Se aplica la regla de Simpson 1/3 con una frecuencia de 0.1 s.
s1_fact_emi_t = s1_m_CO2_t / s1_dist_t    # Se calcula el factor de emisión.
print('La masa total de CO2 es: ', s1_m_CO2_t, '[gCO2]')    # Se muestra la masa total de CO2.
print('El factor de emisión de CO2 del vehículo es: ', s1_fact_emi_t, '[gCO2/km]')     # Se muestra el factor de emisión.

"""### Reglas de Simpson combinadas"""

m_CO2_1_3 = 0     # Se crea una variable para almacenar el valor de la masa total de CO2.
for i in range (0,len(DF_datos_ciclo['t [s]']) - 31,10):
  m_CO2_1_3 = m_CO2_1_3 + (DF_datos_ciclo['t [s]'][i+10] - DF_datos_ciclo['t [s]'][i]) * ((DF_datos_ciclo['m_dot_CO2 [g/s]'][i] +
  4*(DF_datos_ciclo['m_dot_CO2 [g/s]'][i+10]) + DF_datos_ciclo['m_dot_CO2 [g/s]'][i+20]))/6     # Se aplica la regla de Simpson 1/3 con una frecuencia de 1 s, en todos los segmentos, excepto los 3 últimos.

m_CO2_3_8 = (DF_datos_ciclo['t [s]'][20630] - DF_datos_ciclo['t [s]'][20620]) * (((DF_datos_ciclo['m_dot_CO2 [g/s]'][20620] + 
 3*(DF_datos_ciclo['m_dot_CO2 [g/s]'][20630]) + 3*(DF_datos_ciclo['m_dot_CO2 [g/s]'][20640]) + DF_datos_ciclo['m_dot_CO2 [g/s]'][20650])) / (8))     # Se aplica la regla de Simpson 3/8 con una frecuencia de 1 s en los tres últimos segmentos.

s2_m_CO2_t = m_CO2_1_3 + m_CO2_3_8     # Se suman las masas de CO2 obtenidas.

s2_fact_emi_t = s2_m_CO2_t / s2_dist_t     # Se calcula el factor de emisión.
print('La masa total de CO2 es: ', s2_m_CO2_t, '[gCO2]')    # Se muestra la masa total de CO2.
print('El factor de emisión de CO2 del vehículo es: ', s2_fact_emi_t, '[gCO2/km]')     # Se muestra el factor de emisión.

d_fact_emi = {'h':[0.1,1], 'Regla trapezoidal':[t1_fact_emi_t, t2_fact_emi_t], 'Reglas de Simpson':[s1_fact_emi_t, s2_fact_emi_t]}     # Se crea un diccionario con los resulados obtenidos.
DF_fact_emi = pd.DataFrame(d_fact_emi)    # Se crea un DataFrame a partir del diccionario creado.
DF_fact_emi.set_index('h', inplace=True)    # Se utilizan las frecuencias como índices.
DF_fact_emi    # Se muestra el DataFrame para comparar los resultados obtenidos por los diferentes métodos utilizados.
#DF_fact_emi .style.set_caption('Factor de emisión')
display(HTML('<h2>Factor de emisión</h2>'))
display_html(DF_fact_emi)

"""# Conclusiones 
<div align="justify">
 

*  Como podemos observar cuando se hacen los cálculos con los diferentes métodos se obtienen resultados constantes entre ellos, exceptuando los obtenidos para la aceleración. Además se puede apreciar que hay una pequeña pérdida en los resultados con el paso de $1s$ y esto tiene sentido ya que cuando pasamos del paso de $0.1s$ al de $1s$ trabajamos sólo con el 10% del total de datos. Esta diferencia es más notable en el cálculo de la aceleración, como ya se había mencionado, posiblemente porque los puntos máximos y mínimos se encontraban entre los que no se tuvieron en cuenta con el nuevo paso.


</div>
"""